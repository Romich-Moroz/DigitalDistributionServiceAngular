\section{Проектирование и разработка программного средства} 
\label{sec:development}

\subsection{Проектирование архитектуры программного средства} 
\label{sec:development:arch}

В данном курсовом проекте программное средство будет разделено на клиентскую и серверную часть. Рассмотрим архитектуру каждой из частей подробнее.

Архитектура серверной части будет представлять из себя WebApi реализованное с помощью ASP.NET Core. Наборы операций, такие как аутентификация, работа с магазином, администрирование будут представлять из себя отдельные контроллеры, где каждый контроллер может обрабатывать строго определенный набор запросов.
Такой подход очень схож с модульным программированием и упрощает разработку и отладку приложения. Например, контролер аутентификации должен обрабатывать запросы на авторизацию, регистрацию, выход из аккаунта, восстановление аккаунта.
Контроллер администрирование должен уметь обрабатывать запросы на добавление/изменение/удаление информации предназначеной для пользователей. Для того чтобы отличать контроллеры будет использоваться уникальный и подходящий по смыслу префикс для api.
Например для авторизации это '/auth', для магазина это '/store' и т. д. 

Для разграничения доступа к контроллерам будет использоватся механизм Identity, который поддерживается из коробки в ASP.NET Core. Его суть заключается в том, что при авторизации пользователю назначаются роли, 
которые обычно берутся из базы данных. Затем при каждом запросе к серверу проверяются роли пользователя, если требуемых ролей нет, то запрос не обрабатывается. 
В ASP.NET Core для разграничения доступа контроллерам добавляются атрибуты: 
\begin{itemize}
	\item AllowAnonymous -- доступ к контроллеру/методу имеют все, проверок ролей не происходит. Типичным применением такого атрибута являются методы авторизации/регистрации/просмотра публичной информации.
	\item Authorized -- доступ к контроллеру/методу имеют только авторизованные пользователи с любыми ролями. Применяется при просмотре/редактировании информации, специфической для конкретного пользователя.
	\item Authorized, Roles("Admin") - доступ к контроллеру/методу имеет только авторизованный пользователь с ролью "Admin". Применяется для сокрытия администрирующих методов от рядовых пользователей. 
\end{itemize} 

Так как зачастую запросам будут необходимы параметры, то сервер должен проводить их валидацию перед выполнением запроса. Для этого в ASP.NET Core предусмотрены модели запросов.
При запросе данные от клиента автоматически сопоставляются с моделью запроса по принципу совпадения имен. В свою очередь обработчки запросов перед выполнением проверяют валидность модели и в случает ошибки возвращают нужный код.
Модели запросов представляют из себя обычные классы, их отличие заключается в том, что для каждого свойства класса используются атрибуты валидации, например:
\begin{itemize}
	\item Required -- свойство является обязательным.
	\item EmailAddress -- свойство должно соответствовать формату электронной почты.
	\item MaxLength(320) -- свойство должно не превышать заданную длину (320). 
	\item Range(1, 10) -- свойство должно находится в диапазоне от 1 до 10.
\end{itemize} 

Для просмотра контента в требуемых объемах следует реализовать страничное представление. Это лучше делать на стороне сервера, так как в таком случает по сети будет передаваться меньше трафика.

Клиентская часть будет представлять из себя совокупность компонентов, модулей и сервисов, реализованных на Angular.

Компонент - базовый блок для создания приложений в angular. Один компонент является своеобразным строительным блоком, который инкапсулирует в себе всю необходимую функциональность.
Каждый компонент состоит как минимум из файла разметки (.html) в котором можно использовать привязки (bindings) из angular и файла кода (.ts) в котором содержится логика обработки действий пользователя.
При желании компонент может содержать специфические стили (.css).
Все страницы приложения в angular это компоненты, при этом компонент может содержать внутри себя другие компоненты. Таким образом все приложение будет состоять из иерархически упорядоченных компонентов.
На вершине иерархии будет стоять AppComponent, который и является приложением.

При проектировании приложения подразумевается, что компоненты являются лишь удобным посредником для общения пользователя и серверного приложения. Они не содержат бизнес-логики и их назначение сводится к 
отображению информации и использованию специальных сервисов. Сервисы как раз и являются связующим звеном между клиентским и серверным приложением. Их задача состоит в отправке требуемых запрос на сервер и
получение соответствующих результатов в удобной для компонентов форме. Сервисы содержат всю клиентскую бизнес-логику, необходимую для работы приложения. Учитывая тот факт, что Angular использует TypeScript,
то сервисы должны возвращать типизированные объекты. Такие объекты называются моделями и обычно они являются прямым соответствием ответа сервера клиенту. Используя такие модели компоненты могут 
привязаться к полям для последующего отображения пользователю.

Как и в серверном приложении клиенту так же необходима валидация входных данных. В Angular для этого предусмотрены классы Validators. Принцип использвания валидации прост: 
\begin{itemize}
	\item Создать произвольный компонент, который представляет из себя веб-страницу.
	\item В файле кода определить форму и ее поля с соответствующими валидаторами.
	\item В html разметке используя Angular-специфические теги изменять свойства html-элементов в соответствии с результатами валидации.
\end{itemize} 
Типичный пример использования -- запретить отправку формы путем установки тега [disabled] если форма не прошла валидацию.

Несмотря на то, что приложение является одностраничным (Single paged), по факту оно состоит из множества компонентов, которые сменяют друг друга, отсутствие перезагрузки создает иллюзию одностраничности.
Для перехода между компонентами в Angular предусмотрены классы Router и ActivatedRoute. Класс Router служит для простого перехода между компонентами, а класс ActivatedRoute необходим для передачи параметров 
из компонета в компонент через адресную строку. Учитывая тот факт, что помимо простых пользователей существуют и продвинутые, то возникает необходимость защиты от подбора ссылок к функционалу администратора.
В то время как доступ к методам администрирования ограничен на уровне сервера, все равно следует ограничить доступ на уровне клиента. Для этого используется класс guard.
Этот класс предназначен для фильтрации запросов клиента к определенным маршрутам основываясь на некоторых внутренних состояниях приложения. Типичный пример использования -- запретить переход к панели администрирования
если пользователь не администратор.

Следует отметить что оптимальным форматом данных для общения клиента и сервера был выбран формат JSON, так как он прост для понимания, Angular и ASP.NET Core умеют работать с ним из коробки 
и он автоматически сопоставляется с моделями на основе совпадения имен в обоих фреймворках.






